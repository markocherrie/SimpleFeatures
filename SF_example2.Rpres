Simple Features in R
========================================================
author: Mark Cherrie
date: 29/06/18
autosize: false
font-import: http://fonts.googleapis.com/css?family=Open+Sans
font-family: 'Open Sans', sans-serif;

<img src="logos/cresh_twitter.png" style="background-color:transparent; border:0px; box-shadow:none;top:550px; left:0px; position:absolute;z-index:9"></img>

<style>
.small-code pre code {
  font-size: 1em;
}
</style>


What are we doing today? 
========================================================

- **Introduction** (Geospatial analysis in R, What are simple features?, Exposome and nudge theory)
- **Method** (Setup, Google API's, Moves App, Secondary Natural Environment data)
- **Analysis** (Activity Count, Hour Count, Minimal Convex Polygon, Bearing, Processing Google Streetview and Vision, Calculated Semantic Naturalness)
- **Conclusions** (Share visualisations, Summary, next steps, references)
- **Have a go!**


Geospatial Analysis in R 
========================================================

<img src="images/spatial-package-growth.png" style="background-color:transparent; border:0px; box-shadow:none; width:100%; position:absolute;z-index:9"></img>


What are Simple Features?
========================================================

- Simple feature access is an ISO standard that is widely adopted. It is used in spatial databases (PostGIS), GIS (ArcGIS), open source libraries, GeoJSON, GeoSPARQL, etc.
  - Fast reading and writing of data
  - Enhanced plotting performance
  - sf objects can be treated as data frames in most operations
  - sf functions can be combined using %>% operator and works well with the tidyverse collection of R packages

Exposome and Nudge Theory
========================================================

<img src="images/exposomenudge.png" style="background-color:transparent; border:0px; box-shadow:none; width:100%; position:absolute;z-index:9"></img>

Exposome and Nudge Theory
========================================================

<img src="images/nudge.png" style="background-color:transparent; border:0px; box-shadow:none; right: 200px; position:absolute;z-index:9"></img>

Data Science Pipeline
========================================================
<img src="images/pipeline.png" style="background-color:transparent; border:0px; box-shadow:none; right: 100px; position:absolute;z-index:9"></img>


Setup 
========================================================
class: small-code

-  Install external packages
```{r install, eval=TRUE, warning=FALSE, include=TRUE, echo=TRUE}
library(devtools)
#install_github("r-spatial/sf")
#install.packages("RoogleVision", repos = c(getOption("repos"), "http://cloudyr.github.io/drat"))
#install_github("r-spatial/mapview@develop")
```

- Install CRAN packages

```{r install2, eval=F, warning=FALSE, include=TRUE, echo=TRUE}
#install.packages(c("tidyverse",
# "data.table", "pbapply","XML", 
# "dtplyr","sp", "googleway",
# "adehabitatHR", "zoo", "argosfilter"))
```

Setup
========================================================
class: small-code

- Load packages
```{r install3, eval=TRUE, warning=FALSE, include=TRUE, echo=TRUE}

invisible(lapply(c(
         "sf","tidyverse","data.table",
         "pbapply","XML", "dtplyr", 
         "mapview","sp", "googleway", 
         "RoogleVision", "adehabitatHR", 
         "zoo", "argosfilter"), 
         require, character.only = TRUE))
```

- Load external functions
```{r}
# Install User Written Functions
for (i in c("functions")){
  source(paste0(i, ".R"), echo=FALSE)
}

```

Google API's
========================================================

- There is lots of information available in Google application programming interfaces:
  - Places API
  - Directions API
  - Street View API
  - Vision API

- Get an API key: https://developers.google.com/maps/documentation/javascript/get-api-key
- Note that starting July 16, 2018, a new pay-as-you-go pricing plan will go into effect for Maps, Routes, and Places ($200 free a month; e.g. 40,000 directions calls)

Google Maps Data
========================================================
class: small-code

- Get route polyline
```{r warning=FALSE, eval=T}

Usertrack<-GoogleRoute(mapkey= "AIzaSyA8d6ToR2dww8BcfrYhiefkhB0DoZZU8Ck", latO=55.934544, lonO=-3.228447, latD=55.947779, lonD=-3.184145, mode="walking")
plot(Usertrack)
```

Moves App Data
========================================================

- Download the moves data from here: https://accounts.moves-app.com/export

- Unzip it and put it in your working directory

- Now run the functions on the moves_export folder

```{r}
tracks<-get_tracks("data/moves_export/")

activi<-get_activities("data/moves_export/")

places<-get_places("data/moves_export/")
```

- Note we'll concentrate on data from tracks today

Natural Environment Data
========================================================

- OS Open Greenspace
  - https://bit.ly/1I0Fwz3

- The City of Edinburgh Council
  - https://bit.ly/2KyeoMc

Natural Environment Data
========================================================
class: small-code

- **sf::st_read()** is substantially faster than **rgdal::readOGR()**
  - Approx. 14-18 times faster for Shapefile and KML files

```{r}
library(sf)
path="data/opgrsp_essh_nt/OS Open Greenspace (ESRI Shape File) NT/data/"

greenspaces <- read_sf(paste0(path,"NT_GreenspaceSite.shp"))

greenaccesspoints <- 
read_sf(paste0(path, "NT_AccessPoint.shp"))

quietwalks <- read_sf("data/Quiet_routes/Quiet_routes.kml")
```

- Note read_sf instead of st_read 

Plotting Simple Features
========================================================
class: small-code

- Simple plot
```{r, echo=T, eval=F}
tracks %>%
  st_as_sf(coords = c("longitude","latitude")) %>%
  st_set_crs(4326) %>%
  st_cast("MULTIPOINT") %>%
  plot(.)
```

- Note sf function names are relatively consistent and intuitive (all begin with st_)
- Note that you can set the coordinate reference system using EPSG codes (http://epsg.io)

Plotting Simple Features
========================================================
```{r, echo=F, eval=T}
# Simple 
tracks %>%
  st_as_sf(coords = c("longitude","latitude")) %>%
  st_set_crs(4326) %>%
  st_cast("MULTIPOINT") %>%
  plot(.)
```


Plotting Simple Features - Mapview
========================================================
class: small-code
```{r}
# Options
mapviewOptions(basemaps = c("CartoDB.Positron", "OpenStreetMap","Esri.WorldImagery"), layers.control.pos = "topright")

# Plot
m1  <-  mapview(quietwalks,  zcol = "Name")  +
        mapview(greenspaces, zcol = "function.", alpha = 0) + 
        mapview(greenaccesspoints, zcol="accessType", alpha = 0)

# Static Output
# mapshot(m1, file = "quietwalks.png")
```

- Note that alpha=0 takes out the polygon boundary
- Note that the mapshot function is useful if you need a static image

Plotting Simple Features - Mapview
========================================================

<body style="margin:0px;padding:0px;overflow:hidden">
    <iframe src="http://rpubs.com/Marko/SFm1" frameborder="0" scrolling="no" style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px; z-index:1" height="100%" width="100%"></iframe>
</body>


Pipes - Activity Count
========================================================
class: small-code
```{r, eval=F}
# Atribute Data- Activity count
tracks %>%
  st_as_sf(coords = c("longitude","latitude")) %>%
  st_set_crs(4326) %>%
  st_cast("MULTIPOINT") %>%
  mutate(count=1) %>%
  group_by(activity) %>%
  summarise(activitycount=sum(count)) %>%
  ggplot(., aes(x=activity, y=activitycount)) + geom_bar(stat = "identity")
```

- Note that %>% will pipe a value forward into an expression or function call
- Use . if you want to take the manipulated dataframe

Pipes - Activity Count
========================================================

```{r, eval=T, echo=F}
# Atribute Data- Activity count
tracks %>%
  st_as_sf(coords = c("longitude","latitude")) %>%
  st_set_crs(4326) %>%
  st_cast("MULTIPOINT") %>%
  mutate(count=1) %>%
  group_by(activity) %>%
  summarise(activitycount=sum(count)) %>%
  ggplot(., aes(x=activity, y=activitycount)) + geom_bar(stat = "identity")
```

Pipes - Hour Count
========================================================
class: small-code

```{r, eval=FALSE}
# Time data - Hour count
tracks %>%
  sf::st_as_sf(coords = c("longitude","latitude")) %>%
  st_set_crs(4326) %>%
  st_cast("MULTIPOINT") %>%
  mutate(count=1) %>%
  mutate(hour=format(as.POSIXct(strptime(time,"%Y-%m-%dT%H:   %M",tz="GMT")),format = "%H")) %>%
  group_by(hour) %>%
  summarise(hourcount=sum(count)) %>%
  ggplot(., aes(x=hour, y=hourcount)) + geom_bar(stat = "identity")
```

- If you think you will have loaded packaged using the same functions, then use 'packagename::' to make it explicit that the function is from a specific package

Pipes - Hour Count
========================================================

```{r, echo=FALSE, eval=TRUE}
# Time data - Hour count
tracks %>%
  st_as_sf(coords = c("longitude","latitude")) %>%
  st_set_crs(4326) %>%
  st_cast("MULTIPOINT") %>%
  mutate(count=1) %>%
  mutate(hour=format(as.POSIXct(strptime(time,"%Y-%m-%dT%H:%M",tz="GMT")) ,format = "%H"))  %>%
  group_by(hour) %>%
  summarise(hourcount=sum(count)) %>%
  ggplot(., aes(x=hour, y=hourcount)) +geom_bar(stat = "identity")
```


Pipes - Minimal Convex Polygon
========================================================
class: small-code

```{r}
# Geographic data - calculate Minimal convex polygon for each 
tracks_sf_pt<-tracks %>%
  sf::st_as_sf(coords = c("longitude","latitude")) %>%
  sf::st_set_crs(4326) %>%
  sf::st_transform(., 27700)
tracksSPDF<-as(tracks_sf_pt, "Spatial")
track_poly <- mcp(tracksSPDF[,4], percent=95)
mcp_sf_pt<-st_as_sf(track_poly, coords = c("longitude", "latitude"),crs = 27700)
m2<-mapview(mcp_sf_pt, zcol = "area", alpha.regions = 0.3)
```

- st_distance(), st_length() and st_area() will report results with values in the current CRS, so we convert to British National Grid projection for output in metres.
- Conversion of simple feature objects of class sf or sfc into corresponding Spatial* objects is done using the as method, coercing to Spatial


Pipes - Minimal Convex Polygon
========================================================

<body style="margin:0px;padding:0px;overflow:hidden">
    <iframe src="http://rpubs.com/Marko/SFm2" frameborder="0" scrolling="no" style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px; z-index:1" height="100%" width="100%"></iframe>
</body>


Pipes - Bearing
========================================================
class: small-code

```{r}
# Calculate bearing
# convert to spatialMultipointsdataframe
tracks_sf_pt_bearing<-tracks_sf_pt %>%
  st_cast("MULTIPOINT") %>%
  filter(date=="2016-09-01") %>%
  as(., "Spatial")
tracks_sf_pt_bearing<-as.data.frame(tracks_sf_pt_bearing)
bearing<-bearingTrack(tracks_sf_pt_bearing$X1, tracks_sf_pt_bearing$X2)
bearing<-append(bearing, 90) 
tracks_sf_pt_bearing<-cbind(tracks_sf_pt_bearing, bearing)
```

- Note that is also possible to create data.frame objects with geometry list-columns that are not of class sf


Fill Missing and Format
========================================================
class: small-code

```{r}
# fill in missing from last unmissing
tracks_sf_pt_bearing$bearing<-zoo::na.locf(tracks_sf_pt_bearing$bearing)
# Specify degrees clockwise from true north, around the camera locus
tracks_sf_pt_bearing$bearing<-ifelse(tracks_sf_pt_bearing$bearing<0, tracks_sf_pt_bearing$bearing+360, tracks_sf_pt_bearing$bearing+0)
# Format
colnames(tracks_sf_pt_bearing)[1:2]<-c("longitude", "latitude")

# Add bearings to 45 degrees to the left and right of the image
tracks_sf_pt_bearingP45<-tracks_sf_pt_bearing
tracks_sf_pt_bearingM45<-tracks_sf_pt_bearing
tracks_sf_pt_bearingP45$bearing<-tracks_sf_pt_bearing$bearing+45
tracks_sf_pt_bearingM45$bearing<-tracks_sf_pt_bearing$bearing-45
tracks_sf_pt_bearing<-rbind(tracks_sf_pt_bearing, tracks_sf_pt_bearingP45,tracks_sf_pt_bearingM45)


```

Streetview Batch Processing
========================================================
class: small-code

```{r}
# Create a new directory for the streetview images if one doesn't already exist
dir.create(file.path(getwd(), "streetview_images"), showWarnings = FALSE)

# Streetview function
imagedownloader<-function(latitude,longitude, bearing){
  png(paste0("streetview_images/",latitude,"_", longitude,"_", bearing, ".png"), width=640, height=480)
  google_streetview(location = c(latitude,longitude), size = c(640,480), panorama_id = NULL, output = "plot", heading = bearing, fov = 90, pitch = 0, response_check = FALSE, key = "AIzaSyA8d6ToR2dww8BcfrYhiefkhB0DoZZU8Ck")
  dev.off()
}
```

- R can perform system commands (e.g. create directory)

Streetview Batch Processing
========================================================
class: small-code

```{r, eval=FALSE}
# Batch download images
tracks_sf_pt_bearing<-subset(tracks_sf_pt_bearing, select=c("latitude", "longitude", "bearing"))
library(plyr)
mdply(tracks_sf_pt_bearing, imagedownloader)
```

- One of the most useful functions is mdply - a multi-argument function with values taken from columns of an data frame or array, which combines results into a data frame


Streetview Batch Processing
========================================================
- Note that we need to manually check the pictures, some of them are inside, some of them have things in the way, for now we'll just need to manaully delete. 

<img src="images/van.png" style="background-color:transparent; border:0px; box-shadow:none; width:75%; position:absolute;z-index:9"></img>


What is Google Vision?
========================================================

- https://cloud.google.com/vision/docs/drag-and-drop
- https://flovv.shinyapps.io/gVision-shiny/

<body style="margin:0px;padding:0px;overflow:hidden">
    <iframe src="https://cloud.google.com/vision/docs/drag-and-drop" frameborder="0" scrolling="yes" style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px; z-index:1" height="100%" width="100%"></iframe>
</body>


Vision Setup 
========================================================
class: small-code

- See https://github.com/cloudyr/RoogleVision
- APIS & Services > Credentials > Create credentials > OAuth client ID
- Copy and Paste the Client ID and Client Secret into below

```{r, eval=FALSE}
### plugin your credentials for google vision

options("googleAuthR.client_id" = "446553735283-1j1pbpm3u466ofdpr0voot048v2viug2.apps.googleusercontent.com")
options("googleAuthR.client_secret" = "21vHb_c6Y0hEzsNqe2pMdlcw")
options("googleAuthR.scopes.selected" = c("https://www.googleapis.com/auth/cloud-vision"))
googleAuthR::gar_auth(new_user=TRUE)

### Check it's working
getGoogleVisionResponse("https://media-cdn.tripadvisor.com/media/photo-s/02/6b/c2/19/filename-48842881-jpg.jpg", feature="LANDMARK_DETECTION")

```


Vision Batch Processing
========================================================
class: small-code

```{r}
# Setup data frame for mdply
image<-as.data.frame(list.files("streetview_images/",pattern="*.png"))
colnames(image)<-"image"
image$image<-as.character(image$image)

# Create a new directory for the output images if one doesn't already exist
dir.create(file.path(getwd(), "visionoutput"), showWarnings = FALSE)
```


Vision Batch Processing
========================================================
class: small-code
```{r, eval=F}
# Run through Vision
vision<-function(image){
  image2<-paste0(getwd(), "/streetview_images/", image)
  visionoutput <- getGoogleVisionResponse(image2, numResults = 18)[,2:3]
  visionoutput$latitude<-sapply(strsplit(image, "_"), "[", 1)
  visionoutput$longitude<-sapply(strsplit(image, "_"), "[", 2)
  visionoutput$bearing<-gsub(".png", "", sapply(strsplit(image, "_"), "[", 3))
  write.table(visionoutput, paste0("visionoutput/labels.csv"), row.names=F, sep=",", append=T, col.names = FALSE)}
plyr::mdply(image, vision)

```

Calculated Semantic Naturalness
========================================================

<img src="images/CSN_formula.png" style="background-color:transparent; border:0px; box-shadow:none; width:100%; position:absolute;z-index:9"></img>


Calculated Semantic Naturalness
========================================================
class: small-code
```{r, eval=T}
# read data in and format
labeldata<-readr::read_csv("visionoutput/labels.csv", col_names = F)
colnames(labeldata)<-c("description","score", "latitude", "longitude", "bearing")

# get the Hyam labels
labels<-readr::read_csv("data/visionauxdata/labels.csv")

## add the missing labels
misslabels<-readr::read_csv("data/visionauxdata/missinglabels1.csv")
misslabels2<-readr::read_csv("data/visionauxdata/missinglabels2.csv")
labels<-rbind(labels, misslabels, misslabels2)

```

Calculated Semantic Naturalness
========================================================
class: small-code

```{r}
# get id colum
labeldata$photoid <- labeldata %>% 
  group_indices(latitude, longitude)

# remove photo labels that didnt work
labeldata<-labeldata[!(labeldata$score<0),]

# merge with labels
labeldata<-merge(labeldata, labels, by="description", all.x=T)

# create labels that haven't been defined
missinglabels<-subset(labeldata, is.na(naturalness))
if (nrow(missinglabels)>0){print("Add missing labels to label dataframe")}

# if Message then add the label categorise as natural, artificial or ambigious
#missinglabels<-as.data.frame(unique(missinglabels$description))
#colnames(missinglabels)<-"description"
#write.csv(missinglabels, "data/visionauxdata/missinglabels2.csv", row.names=F)

```


Calculated Semantic Naturalness
========================================================
class: small-code

```{r}
# create Calculated semantic naturalness
labeldata <-
  labeldata %>%
  group_by(photoid) %>%
  mutate(CSN=(sum(naturalness == 1)/n())-(sum(naturalness == -1)/n())) %>%
  mutate(CSN = round(CSN, 2)) %>%
  distinct(latitude, longitude, photoid, CSN)
# Plot
mapviewOptions(basemaps = c("Esri.WorldImagery", "OpenStreetMap","CartoDB.Positron"),
               layers.control.pos = "topright")
m3<-labeldata %>%
  sf::st_as_sf(coords = c("longitude","latitude")) %>%
  sf::st_set_crs(4326) %>%
  sf::st_cast("MULTIPOINT") %>%
  mapview(., zcol = "CSN", cex = "CSN", color = "black")
```


Calculated Semantic Naturalness
========================================================

<body style="margin:0px;padding:0px;overflow:hidden">
    <iframe src="http://rpubs.com/Marko/SFm3" frameborder="0" scrolling="no" style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px; z-index:1" height="100%" width="100%"></iframe>
</body>

Share Data Visualisations
========================================================
```{r, eval=F}
# Let's bring it all together now
sync(m1, m2, m3)

# let's Publish to Rpubs!
# http://rpubs.com/Marko/simplefeatures
```


Summary
========================================================
<body style="margin:0px;padding:0px;overflow:hidden">
    <iframe src="http://rpubs.com/Marko/simplefeatures" frameborder="0" scrolling="no" style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px; z-index:1" height="100%" width="100%"></iframe>
</body>
 

Next Steps
========================================================

- Data Collection
  - Other google vision API outputs?
  - Build Moves API downloader (https://bit.ly/2KupFgq)
  - Replicate with Google Timeline data (https://bit.ly/2yR0KlR)
- Data Analysis
  - Build a pipe that calculates distance to the nearest park and nearest access point for each activity space point?
- Data Visualisation
  - How could the mapview code be modified to create a popup that is the street view image?
 

References
=======================================================

- https://cran.r-project.org/web/packages/sf/
- https://bookdown.org/robinlovelace/geocompr/
- https://www.azavea.com/blog/2017/08/30/spatial-analysis-pipelines-in-r-with-simple-features/
- https://cengel.github.io/rspatial/
- https://github.com/r-spatial/mapview
- http://walkerke.github.io/2016/12/spatial-pipelines/
- http://www.markcherrie.net/talk/simplefeatures/
- http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0169357

